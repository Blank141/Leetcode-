## 1. 两数之和
给定一个整数数组 nums 和一个整数目标值 target，请你在该数组中找出 和为目标值 target  的那 两个 整数，并返回它们的数组下标。  
你可以假设每种输入只会对应一个答案。但是，数组中同一个元素在答案里不能重复出现。  
你可以按任意顺序返回答案。  

示例 1： 
输入：nums = [2,7,11,15], target = 9  
输出：[0,1]  
解释：因为 nums[0] + nums[1] == 9 ，返回 [0, 1] 。  

### 方法 1：哈希表
```
class Solution {
public:
    vector<int> twoSum(vector<int>& nums, int target) {
        unordered_map<int, int> hashtable;
        for (int i = 0; i < nums.size(); ++i) {
            auto it = hashtable.find(target - nums[i]);
            if (it != hashtable.end()) {
                return {it->second, i};
            }
            hashtable[nums[i]] = i;
        }
        return {};
    }
};

作者：御三五 🥇
链接：https://leetcode.cn/problems/two-sum/solutions/657225/tu-jie-guan-fang-tui-jian-ti-jie-liang-s-02xs/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
```
### 方法2 双循环

## 2. 两数相加
给你两个 非空 的链表，表示两个非负的整数。它们每位数字都是按照 逆序 的方式存储的，并且每个节点只能存储 一位 数字。  
请你将两个数相加，并以相同形式返回一个表示和的链表。  
你可以假设除了数字 0 之外，这两个数都不会以 0 开头。  
![](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2021/01/02/addtwonumber1.jpg)

### 方法1：
遍历链表 l1 l2  
注意一长一短的情况  
储存进位 carry  
创建链表 value = sum = l1 + l2 + carry  

## 3. 无重复字符的最长子串
给定一个字符串 s ，请你找出其中不含有重复字符的 最长子串 的长度。  

示例 1:  
输入: s = "abcabcbb"  
输出: 3   
解释: 因为无重复字符的最长子串是 "abc"，所以其长度为 3。  

### 方法1：
左指针 i 右指针 j  
数组储存 字符出现次数
右字符==0 j++
右字符==1 i++ 右字符次数-1

int（4ms）赋值居然比bool（8ms）快

### 方法2：队列/滑动窗口
也可以用问题一的哈希表存储队列字符

```
class Solution:
    def problemName(self, s: str) -> int:
        # Step 1: 定义需要维护的变量们 (对于滑动窗口类题目，这些变量通常是最小长度，最大长度，或者哈希表)
        x, y = ..., ...

        # Step 2: 定义窗口的首尾端 (start, end)， 然后滑动窗口
        start = 0
        for end in range(len(s)):
            # Step 3: 更新需要维护的变量, 有的变量需要一个if语句来维护 (比如最大最小长度)
            x = new_x
            if condition:
                y = new_y

            '''
            ------------- 下面是两种情况，读者请根据题意二选1 -------------
            '''
            # Step 4 - 情况1
            # 如果题目的窗口长度固定：用一个if语句判断一下当前窗口长度是否达到了限定长度 
            # 如果达到了，窗口左指针前移一个单位，从而保证下一次右指针右移时，窗口长度保持不变, 
            # 左指针移动之前, 先更新Step 1定义的(部分或所有)维护变量 
            if 窗口长度达到了限定长度:
                # 更新 (部分或所有) 维护变量 
                # 窗口左指针前移一个单位保证下一次右指针右移时窗口长度保持不变

            # Step 4 - 情况2
            # 如果题目的窗口长度可变: 这个时候一般涉及到窗口是否合法的问题
            # 如果当前窗口不合法时, 用一个while去不断移动窗口左指针, 从而剔除非法元素直到窗口再次合法
            # 在左指针移动之前更新Step 1定义的(部分或所有)维护变量 
            while 不合法:
                # 更新 (部分或所有) 维护变量 
                # 不断移动窗口左指针直到窗口再次合法

        # Step 5: 返回答案
        return ...

作者：Eason
链接：https://leetcode.cn/problems/longest-substring-without-repeating-characters/solutions/876061/yi-ge-mo-ban-miao-sha-10dao-zhong-deng-n-sb0x/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
```
## 4. 寻找两个正序数组的中位数(困难)
给定两个大小分别为 m 和 n 的正序（从小到大）数组 nums1 和 nums2。请你找出并返回这两个正序数组的 中位数 。  
算法的时间复杂度应该为 O(log (m+n)) 。  

示例 1：  
输入：nums1 = [1,3], nums2 = [2]  
输出：2.00000  
解释：合并数组 = [1,2,3] ，中位数 2  

### 方法1:二分查找
找到第k大的数  
k = (m+n+1)/2  
找两数组中k/2处比大小  
小的前面的都小 前面 i=k/2-1 去掉  
找到第k-i大的数  
······  

### 方法2:划分数组
12/36  
456/789  
--》
123/6  
45/6789  

小trick
123->1#2#3 
1234->1#2#3#4  
和永远为偶数

0 1 2  
1#2#3  
01234  

## 5. 最长回文子串
### 方法1:中心往两边
用到前面的trick
加#号忽略奇偶数

### 方法2:动态规划
动态规划听起来很高大上。其实说白了就是空间换时间，将计算结果暂存起来，避免重复计算。  
我们用一个 boolean dp[l][r] 表示字符串从 l 到 r 这段是否为回文。  
试想如果 dp[l][r]=true，我们要判断 dp[l-1][r+1] 是否为回文。只需要判断字符串在(l-1)和（r+1)两个位置是否为相同的字符。   
进入正题，动态规划关键是找到初始状态和状态转移方程。   
初始状态，l=r 时，此时 dp[l][r]=true。   
状态转移方程，dp[l][r]=true 并且(l-1)和（r+1)两个位置为相同的字符，此时 dp[l-1][r+1]=true。
dp[l][r] = dp[l+1][r+1] && s[l]==s[r]  

### 方法3:中心往一边
先向一边看有没有回文再看另一边

## 6. Z 字形变换
### 方法1：
0             0+t                    0+2t                     0+3t  
1      t-1    1+t            0+2t-1  1+2t            0+3t-1   1+3t  
2  t-2        2+t  0+2t-2            2+2t  0+3t-2             2+3t    
3             3+t                    3+2t                     3+3t  

### 方法2：SIN函数（可能累计误差）

## 7. 整数反转
给你一个 32 位的有符号整数 x ，返回将 x 中的数字部分反转后的结果。  
如果反转后整数超过 32 位的有符号整数的范围 [−231,  231 − 1] ，就返回 0。  
假设环境不允许存储 64 位整数（有符号或无符号）。  

遇事不决用long long

注意INT_MAX INT_MIN

## 8. 字符串转换整数 (atoi)
步骤1：读符号 去空格  
步骤2：读数字* 10 再读下一位

## 9. 回文数
同整数反转

## 10. 正则表达式匹配
### 方法一：从前往后（没写出来艹）
### 方法二：从后往前（递归）太占内存了
### 方法三：动态规划
```
                if (p[j - 1] == '*') {
                    dp[i][j] |= dp[i][j - 2];
                    if ( i != 0 && (s[i - 1] == p[j - 2] || p[j - 2] == '.') ) {
                        dp[i][j] |= dp[i - 1][j];
                    }
                }
                else {
                    if ( i != 0 && (s[i - 1] == p[j - 1] || p[j - 1] == '.') ) {
                        dp[i][j] |= dp[i - 1][j - 1];
                    }
                }
```                
